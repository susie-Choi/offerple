# Product Overview

## Zero-Day Defense: LLM 기반 잠재 위협 사전 탐지 시스템

이 프로젝트는 **제로데이 공격을 사후 대응이 아닌 사전 방어**하는 새로운 패러다임을 제시합니다. LLM과 그래프 분석을 결합하여 아직 발견되지 않은 잠재적 취약점을 예측하고, 치명적인 위협이 발생할 가능성이 높은 영역을 선제적으로 식별합니다.

## 핵심 문제 정의
- **기존 한계**: 알려진 취약점(CVE) 공개 후 패치하는 사후 대응(Reactive) 방식
- **시간적 공백**: CVE 공개부터 패치 적용까지의 시간 동안 치명적 피해 발생
- **자원 제약**: 모든 패키지를 동일하게 모니터링할 수 없음
- **제로데이 위협**: 알려지지 않은 취약점에 대한 선제적 방어 불가능

## 연구 목표
- **최종 목표**: NeurIPS, ICML, ICLR 등 top-tier AI 학회 논문 투고 및 accept
- **핵심 기여**: 제로데이 공격의 잠재 위험 지대(Latent Risk Zone)를 선제적으로 식별하는 AI 시스템
- **실용적 가치**: 제한된 보안 자원을 가장 치명적인 위협에 집중 배치
- **패러다임 전환**: 사후 대응(Reactive)에서 사전 방어(Proactive)로의 전환

## 4단계 방법론 (Zero-Day Defense Framework)

### Phase 1: 핵심 위협 식별 및 중요도 분석
- **목표**: 오픈소스 생태계에서 '붕괴 시 파급력이 가장 큰' 핵심 노드(Critical Nodes) 식별
- **방법**: 
  - 그래프 중심성 분석 (PageRank, Betweenness Centrality)
  - 하류 의존성(Downstream Impact) 규모 측정
  - CVSS Critical 등급 취약점 이력 분석
- **차별점**: 단순 연결 수가 아닌 '실제 파급력' 기반 중요도 측정

### Phase 2: 위협 군집 분석 및 연관성 탐색
- **목표**: 핵심 노드들의 숨겨진 연관성을 찾아 '위협 군집(Threat Cluster)' 도출
- **방법**:
  - 인적 요인 제외, 오픈소스 코드/구조 기반 취약점만 필터링
  - 공통 개발자, 유사 코드 구조(Code Embedding), 공통 의존성 분석
  - 그래프 커뮤니티 탐지 알고리즘 적용
- **차별점**: 표면적 의존성이 아닌 심층적 연관성 발견

### Phase 3: LLM 기반 사전 신호 분석 (핵심 독창성)
- **목표**: CVE 공개 전에 관찰 가능한 '사전 신호(Early Signals)'를 통해 잠재 위험 예측
- **핵심 원칙**: CVSS 점수나 공격 정보가 없는 상태에서 예측 가능한 신호만 사용
- **사용 가능한 신호들**:
  
  **1. 과거 취약점 패턴 신호**
  - 해당 패키지의 과거 취약점 유형 및 빈도
  - 유사 군집 내 다른 패키지들의 취약점 이력
  - 예: "Struts2는 과거 5년간 7번의 RCE 취약점 발생 → 고위험 패턴"
  
  **2. 코드 레벨 위험 신호**
  - 위험한 함수 사용 빈도 (strcpy, eval, exec, deserialize 등)
  - 코드 복잡도 (Cyclomatic Complexity)
  - 최근 대규모 코드 변경 (특히 보안 관련 영역)
  - 예: "최근 3개월간 네트워크 입력 처리 코드 50% 변경 → 주의 필요"
  
  **3. 유지보수 활동 신호**
  - 보안 패치 빈도 및 속도
  - 개발자 활동 패턴 (활발함 vs 방치)
  - 이슈 트래커의 보안 관련 논의
  - 예: "6개월간 보안 이슈 5건 미해결 → 관리 부실 신호"
  
  **4. 커뮤니티 및 생태계 신호**
  - 급격한 다운로드 수 증가 (공격자의 관심 증가 가능)
  - 포크 수 급증 (보안 문제 우회 시도 가능)
  - 관련 패키지들의 취약점 발생 추세
  
- **LLM의 역할**: 이러한 다차원 신호들을 종합하여 "유추 기반 추론" 수행
  - 예: "패키지 A는 과거 메모리 누수 취약점 3회 + libX 사용 + 최근 메모리 관리 코드 변경 → 동일 군집의 B, C도 libX 사용 + 유사 코드 패턴 → 잠재 위험 높음"
  
- **잠재 위험 점수(Latent Risk Score)**: 사전 신호들의 가중 조합으로 계산
- **차별점**: CVE 정보 없이 순수하게 관찰 가능한 신호만으로 예측

### Phase 4: 3D 시각화 및 방어 전략 수립
- **목표**: 잠재 위험 지대를 직관적으로 시각화하여 자원 배치 최적화
- **방법**:
  - X, Y축: 패키지 간 기술적/의미적 유사도 기반 생태계 지도
  - Z축: 잠재 위험 점수 (높이로 표현)
  - 3D 공간에서 Z축이 높은 영역 = 잠재 위험 지대
- **차별점**: 추상적 위험도를 직관적 3D 공간으로 변환

## 핵심 연구 기여 (Key Contributions)

### AI/ML 관점
1. **LLM 기반 유추 추론**: 과거 취약점 패턴에서 미래 위협을 유추하는 새로운 LLM 응용
2. **그래프 + LLM 융합**: 그래프 구조 분석과 LLM의 패턴 인식을 결합한 하이브리드 시스템
3. **잠재 위험 정량화**: CVE가 없는 패키지의 위험도를 정량적으로 측정하는 새로운 메트릭
4. **3D 위험 지도**: 고차원 위험 정보를 직관적 3D 공간으로 변환하는 시각화 기법

### 보안 관점
5. **패러다임 전환**: 사후 대응(Reactive)에서 사전 방어(Proactive)로의 전환
6. **자원 최적화**: 제한된 보안 자원을 가장 치명적인 위협에 집중 배치
7. **실세계 검증**: Log4Shell, Equifax 같은 실제 사고를 사전에 탐지할 수 있었는지 검증

### 학술적 기여
8. **새로운 연구 방향**: Zero-Day Defense라는 새로운 연구 분야 개척
9. **벤치마크 구축**: 잠재 위협 탐지 성능을 평가할 수 있는 새로운 벤치마크 제시

## 연구 개발 철학
- **문제 중심**: 기술이 아닌 '제로데이 방어'라는 실제 문제에서 출발
- **독창성 우선**: 기존 연구의 점진적 개선이 아닌 완전히 새로운 접근법 제시
- **실용성 검증**: 과거 실제 사고(Log4Shell, Equifax)를 사전에 탐지할 수 있었는지 검증
- **재현 가능성**: 모든 데이터, 코드, 실험 결과를 공개하여 연구 재현성 보장
- **학술적 엄밀성**: 정량적 평가와 통계적 유의성 검증을 통한 과학적 검증

## 평가 지표 (Evaluation Metrics)

### 잠재 위협 탐지 성능
- **Precision at K**: 상위 K개 고위험 예측 중 실제로 취약점이 발생한 비율
- **Recall at K**: 실제 발생한 Critical/High 취약점 중 상위 K개 예측에 포함된 비율
- **Lead Time**: CVE 공개 시점 대비 얼마나 일찍 위험 신호를 탐지했는지 (일/주/월 단위)
- **False Positive Rate**: 잘못된 경보 비율 (실용성의 핵심 지표)
- **Signal-to-Noise Ratio**: 유의미한 신호 대비 노이즈 비율

### 그래프 분석 성능
- **Critical Node Identification**: 실제 치명적 취약점이 발생한 노드를 핵심 노드로 식별한 비율
- **Cluster Quality**: 위협 군집의 응집도(Cohesion) 및 분리도(Separation)
- **Impact Prediction Accuracy**: 취약점 발생 시 영향 범위 예측 정확도

### LLM 추론 성능
- **Signal Integration Accuracy**: 다차원 신호를 종합하여 올바른 결론을 도출하는 능력
- **Analogy Reasoning**: 과거 패턴에서 유사 상황을 유추하는 정확도
- **Pattern Recognition**: 취약점으로 이어지는 코드/활동 패턴 인식 능력
- **Risk Score Calibration**: 잠재 위험 점수와 실제 취약점 심각도의 상관관계

### 실세계 검증
- **Historical Case Study**: Log4Shell, Equifax 등을 사전에 탐지할 수 있었는지
- **Time-to-Detection**: 실제 CVE 공개 대비 얼마나 빨리 탐지했는지
- **Resource Efficiency**: 전체 패키지 대비 몇 %만 모니터링하여 몇 %의 위협을 탐지했는지

## 실세계 검증 전략

### 과거 사고 재현 실험 (Historical Validation)
**Log4Shell 사태 (CVE-2021-44228) - 2021년 12월**
- **검증 질문**: "2021년 11월 시점에 CVE 정보 없이 Log4j를 고위험으로 식별할 수 있었는가?"
- **사용 가능한 신호 (CVE 공개 전)**:
  - **그래프 신호**: 수백만 프로젝트가 의존하는 초고중심성 노드
  - **코드 신호**: JNDI lookup 기능 사용 (과거 다른 라이브러리에서 유사 취약점 존재)
  - **활동 신호**: 로깅 라이브러리임에도 네트워크 기능 포함 (이상 패턴)
  - **이력 신호**: 과거 보안 패치 이력은 있으나 빈도 낮음
- **사용 불가능한 정보**: CVSS 점수, 공격 벡터, 실제 공격 사례
- **성공 기준**: CVE 공개 1개월 전에 상위 1% 고위험 패키지로 식별

**Equifax 사태 (CVE-2017-5638) - 2017년 3월**
- **검증 질문**: "2017년 2월 시점에 CVE 정보 없이 Struts2를 고위험으로 식별할 수 있었는가?"
- **사용 가능한 신호 (CVE 공개 전)**:
  - **이력 신호**: 2013-2016년 사이 5번의 RCE 취약점 발생 (명확한 고위험 패턴)
  - **코드 신호**: 파일 업로드 및 Content-Type 파싱 코드 (과거 취약점 다발 영역)
  - **생태계 신호**: 대규모 엔터프라이즈 시스템에서 광범위하게 사용
  - **활동 신호**: 보안 패치는 빠르나 취약점 발생 빈도가 높음
- **사용 불가능한 정보**: CVSS 9.8 점수, Jakarta Multipart parser 취약점 세부사항
- **성공 기준**: 지속적으로 상위 5% 고위험 패키지로 분류 (과거 이력 기반)

### 실시간 검증 (Prospective Validation)
- **방법**: 현재 시점의 사전 신호만으로 잠재 위험 지대를 예측하고, 향후 6개월~1년간 실제 CVE 발생 추적
- **엄격한 제약**: CVE 정보, CVSS 점수, 공격 정보 등 미래 정보는 일체 사용 금지
- **목표**: 순수하게 관찰 가능한 신호만으로 예측한 패키지에서 실제 취약점 발견 여부 검증
- **윤리적 고려**: 
  - 발견한 잠재 위험은 해당 프로젝트에 책임감 있게 보고
  - 악용 가능성이 있는 구체적 취약점 정보는 공개하지 않음
  - Responsible Disclosure 원칙 준수

### 연구의 사회적 임팩트
- **경제적 가치**: Log4Shell(10년 복구 비용), Equifax(14억 달러) 같은 피해를 사전에 예방
- **패러다임 전환**: "제로데이는 막을 수 없다"는 고정관념을 깨는 새로운 접근
- **실용적 기여**: 보안 담당자가 실제로 사용할 수 있는 구체적 도구 제공

## 의사소통 가이드라인
- **모든 설명과 문서화는 반드시 한국어로 작성**
- 코드 주석도 가능한 한 한국어로 작성
- 사용자 대면 메시지와 오류 메시지는 한국어로 작성
- 논문 작성 시에는 영어 사용 (학술 표준)

## 연구
의 핵심 제약 및 원칙

### 정보 사용 제약 (Information Constraint)
**사용 가능한 정보 (CVE 공개 전 관찰 가능)**:
- 그래프 구조 (의존성 관계, 중심성)
- 과거 취약점 이력 및 패턴
- 코드 레벨 특징 (위험 함수, 복잡도)
- 개발 활동 패턴 (커밋, 이슈, PR)
- 커뮤니티 신호 (다운로드, 포크, 스타)

**사용 불가능한 정보 (미래 정보)**:
- CVSS 점수 (CVE 공개 후에만 존재)
- 공격 벡터 세부사항
- 실제 공격 사례 및 피해 규모
- CVE 설명 및 패치 정보

### 시간적 엄밀성 (Temporal Rigor)
- 모든 예측은 해당 시점에 실제로 알 수 있었던 정보만 사용
- "미래를 보고 과거를 예측"하는 Data Leakage 절대 금지
- Historical Validation 시 시간 순서 엄격히 준수

### 실용성 원칙 (Practicality Principle)
- False Positive를 최소화하여 실제 사용 가능한 시스템 구축
- 보안 담당자가 실제로 조치할 수 있는 수준의 경보 생성
- 전체 패키지의 1-5%만 고위험으로 분류 (자원 효율성)