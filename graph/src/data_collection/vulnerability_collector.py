"""
취약점 이력 데이터 수집 모듈
NVD, GitHub Advisory Database에서 CVE 데이터 수집
"""
import requests
import json
import logging
from typing import Dict, List, Optional
from datetime import datetime
import time

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class VulnerabilityCollector:
    """과거 취약점 이력 수집 (CVE 데이터)"""
    
    def __init__(self, cutoff_date: str, nvd_api_key: Optional[str] = None):
        """
        Args:
            cutoff_date: 이 날짜 이전의 CVE만 수집 (YYYY-MM-DD)
            nvd_api_key: NVD API 키 (선택사항, 없으면 rate limit 적용)
        """
        self.cutoff_date = cutoff_date
        self.nvd_api_key = nvd_api_key
        self.nvd_base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        
    def collect_cves_for_product(self, product_name: str) -> List[Dict]:
        """특정 제품/패키지의 CVE 목록 수집"""
        try:
            params = {
                "keywordSearch": product_name,
                "resultsPerPage": 100,
            }
            
            if self.nvd_api_key:
                headers = {"apiKey": self.nvd_api_key}
            else:
                headers = {}
            
            response = requests.get(
                self.nvd_base_url,
                params=params,
                headers=headers,
                timeout=30
            )
            
            if response.status_code != 200:
                logger.warning(f"NVD API 호출 실패: {response.status_code}")
                return []
            
            data = response.json()
            vulnerabilities = data.get("vulnerabilities", [])
            
            # cutoff 날짜 이전 CVE만 필터링
            filtered_cves = []
            for vuln in vulnerabilities:
                cve_data = vuln.get("cve", {})
                published_date = cve_data.get("published", "").split("T")[0]
                
                if published_date <= self.cutoff_date:
                    filtered_cves.append(self._parse_cve_data(cve_data))
            
            logger.info(f"{product_name}: {len(filtered_cves)}개 CVE 수집 (cutoff: {self.cutoff_date})")
            return filtered_cves
            
        except Exception as e:
            logger.error(f"CVE 수집 중 오류 ({product_name}): {e}")
            return []
    
    def _parse_cve_data(self, cve_data: Dict) -> Dict:
        """CVE 데이터 파싱"""
        cve_id = cve_data.get("id", "")
        
        # CVSS 점수 추출
        metrics = cve_data.get("metrics", {})
        cvss_v3 = metrics.get("cvssMetricV31", [{}])[0] if metrics.get("cvssMetricV31") else {}
        cvss_data = cvss_v3.get("cvssData", {})
        
        # 취약점 설명
        descriptions = cve_data.get("descriptions", [])
        description = descriptions[0].get("value", "") if descriptions else ""
        
        # 취약점 유형 추출 (CWE)
        weaknesses = cve_data.get("weaknesses", [])
        cwe_ids = []
        for weakness in weaknesses:
            for desc in weakness.get("description", []):
                cwe_ids.append(desc.get("value", ""))
        
        return {
            "cve_id": cve_id,
            "published_date": cve_data.get("published", "").split("T")[0],
            "last_modified": cve_data.get("lastModified", "").split("T")[0],
            "cvss_score": cvss_data.get("baseScore", 0.0),
            "cvss_severity": cvss_data.get("baseSeverity", "UNKNOWN"),
            "cvss_vector": cvss_data.get("vectorString", ""),
            "description": description,
            "cwe_ids": cwe_ids,
            "vulnerability_type": self._classify_vulnerability_type(description, cwe_ids),
        }
    
    def _classify_vulnerability_type(self, description: str, cwe_ids: List[str]) -> str:
        """취약점 유형 분류"""
        desc_lower = description.lower()
        
        # RCE (Remote Code Execution)
        if any(keyword in desc_lower for keyword in ["remote code execution", "rce", "arbitrary code"]):
            return "RCE"
        
        # SQL Injection
        if any(keyword in desc_lower for keyword in ["sql injection", "sqli"]):
            return "SQL_INJECTION"
        
        # XSS
        if any(keyword in desc_lower for keyword in ["cross-site scripting", "xss"]):
            return "XSS"
        
        # Memory Corruption
        if any(keyword in desc_lower for keyword in ["buffer overflow", "memory corruption", "use after free"]):
            return "MEMORY_CORRUPTION"
        
        # Deserialization
        if any(keyword in desc_lower for keyword in ["deserialization", "unsafe deserialization"]):
            return "DESERIALIZATION"
        
        return "OTHER"
    
    def collect_batch(self, package_names: List[str], output_file: str):
        """여러 패키지의 CVE를 배치로 수집"""
        results = {}
        total = len(package_names)
        
        logger.info(f"총 {total}개 패키지의 CVE 수집 시작 (cutoff: {self.cutoff_date})")
        
        for idx, package_name in enumerate(package_names, 1):
            if idx % 10 == 0:
                logger.info(f"진행률: {idx}/{total} ({idx/total*100:.1f}%)")
            
            cves = self.collect_cves_for_product(package_name)
            if cves:
                results[package_name] = cves
            
            # NVD API rate limiting (without key: 5 requests per 30 seconds)
            if not self.nvd_api_key:
                time.sleep(6)
            else:
                time.sleep(0.6)
        
        # 결과 저장
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)
        
        logger.info(f"CVE 수집 완료: {len(results)}개 패키지 -> {output_file}")
        return results


if __name__ == "__main__":
    # 사용 예시: Log4Shell Historical Validation
    collector = VulnerabilityCollector(cutoff_date="2021-11-01")
    
    # Log4j의 과거 취약점 이력 수집 (2021년 11월 이전)
    log4j_cves = collector.collect_cves_for_product("log4j")
    print(f"Log4j CVE 수: {len(log4j_cves)}")
    print(json.dumps(log4j_cves[:2], indent=2, ensure_ascii=False))
