"""Collect Exploit-DB data for CVE IDs."""
import argparse
import json
import logging
import os
from datetime import datetime, timezone
from pathlib import Path

from tqdm import tqdm

from rota.spokes.exploit_db import ExploitDBCollector as ExploitDBDataSource

logger = logging.getLogger(__name__)


def main():
    parser = argparse.ArgumentParser(
        description="Collect Exploit-DB data for CVE IDs"
    )
    parser.add_argument(
        "cve_list",
        type=Path,
        help="Path to file containing CVE IDs (one per line)",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("data/raw/bulk_exploits_data.jsonl"),
        help="Output JSONL file",
    )
    parser.add_argument(
        "--log-level",
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR"],
    )
    
    args = parser.parse_args()
    logging.basicConfig(
        level=getattr(logging, args.log_level.upper()),
        format="%(asctime)s - %(levelname)s - %(message)s",
    )
    
    # Read CVE IDs
    with args.cve_list.open("r") as f:
        cve_ids = [line.strip() for line in f if line.strip()]
    
    logger.info(f"Loaded {len(cve_ids)} CVE IDs")
    
    # Initialize Exploit-DB data source
    exploit_source = ExploitDBDataSource(timeout=30.0)
    
    # Collect ALL exploits at once (much faster!)
    logger.info("Downloading full Exploit-DB CSV...")
    args.output.parent.mkdir(parents=True, exist_ok=True)
    
    try:
        result = exploit_source.collect_all_exploits(cutoff=datetime.now(timezone.utc))
        all_exploits = result.payload["exploits"]
        
        logger.info(f"Downloaded {len(all_exploits)} total exploits")
        logger.info("Filtering by CVE IDs...")
        
        # Build CVE set for fast lookup
        cve_set = set(cve_ids)
        
        # Filter exploits by CVE IDs
        collected = 0
        with args.output.open("w", encoding="utf-8") as f:
            for exploit in tqdm(all_exploits, desc="Filtering exploits"):
                codes = exploit.get("codes", "")
                # Check if any of our CVE IDs are in this exploit
                for cve_id in cve_set:
                    if cve_id in codes:
                        record = {
                            "source": "exploit_db",
                            "package": cve_id,
                            "collected_at": datetime.now(timezone.utc).isoformat(),
                            "payload": {
                                "cve_id": cve_id,
                                "exploit": exploit,
                            },
                        }
                        f.write(json.dumps(record, ensure_ascii=False) + "\n")
                        collected += 1
                        break  # Don't duplicate if multiple CVEs match
        
        errors = 0
        
    except Exception as e:
        logger.error(f"Error collecting exploits: {e}", exc_info=True)
        collected = 0
        errors = len(cve_ids)
    
    logger.info(f"\n{'='*60}")
    logger.info(f"Exploit Collection Complete")
    logger.info(f"  Collected: {collected}")
    logger.info(f"  Errors: {errors}")
    logger.info(f"  Output: {args.output}")
    logger.info(f"{'='*60}")


if __name__ == "__main__":
    main()
